-- Serviços essenciais
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Player = Players.LocalPlayer

-- Configuração da UI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AutoParryUI"
screenGui.Parent = Player:WaitForChild("PlayerGui")

local statusFrame = Instance.new("Frame")
statusFrame.Size = UDim2.new(0.25, 0, 0.07, 0)
statusFrame.Position = UDim2.new(0.05, 0, 0.9, 0)
statusFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
statusFrame.BackgroundTransparency = 0.5
statusFrame.BorderSizePixel = 0
statusFrame.Parent = screenGui

local statusLabel = Instance.new("TextLabel")
statusLabel.Text = "🔍 PROCURANDO BOLA..."
statusLabel.Size = UDim2.new(1, 0, 1, 0)
statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
statusLabel.BackgroundTransparency = 1
statusLabel.Font = Enum.Font.GothamBold
statusLabel.TextSize = 14
statusLabel.Parent = statusFrame

-- Sistema de detecção aprimorado
local function GetDeathBall()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Name == "Part" then
            -- Verificação adicional dos componentes da bola
            if obj:FindFirstChild("DeflectParticles") and obj:FindFirstChild("Trail") then
                return obj
            end
        end
    end
    return nil
end

-- Detecção de colisão precisa
local function ShouldParry(ball, character)
    if not character or not ball then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    -- 1. Verificação por raycasting
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character, ball}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = workspace:Raycast(
        ball.Position,
        (hrp.Position - ball.Position).Unit * 50,
        raycastParams
    )
    
    -- 2. Cálculo de tempo de impacto
    local ballVelocity = ball.AssemblyLinearVelocity
    local distance = (hrp.Position - ball.Position).Magnitude
    local timeToImpact = distance / math.max(ballVelocity.Magnitude, 0.1)
    
    -- 3. Verificação de direção
    local directionToPlayer = (hrp.Position - ball.Position).Unit
    local isApproaching = (ballVelocity.Unit:Dot(directionToPlayer) > 0.9)
    
    -- Condições combinadas para parry perfeito
    return timeToImpact < 0.3 and isApproaching and raycastResult and raycastResult.Instance == hrp
end

-- Sistema principal
RunService.Heartbeat:Connect(function()
    local ball = GetDeathBall()
    local character = Player.Character
    
    if not ball or not character then
        statusLabel.Text = "🔍 BOLA NÃO DETECTADA"
        return
    end
    
    if ShouldParry(ball, character) then
        mouse1click()
        statusLabel.Text = "⚡ PARRY EXECUTADO!"
        task.delay(0.2, function()
            statusLabel.Text = "🟢 PRONTO PARA PARRY"
        end)
    else
        statusLabel.Text = string.format("🎯 BOLA DETECTADA (Dist: %.1f)", (character.HumanoidRootPart.Position - ball.Position).Magnitude)
    end
end)

-- Toggle com F10
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.F10 then
        screenGui.Enabled = not screenGui.Enabled
    end
end)

print("Sistema de AutoParry carregado com tecnologia de detecção avançada!")
